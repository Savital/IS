# КУРС лекций по ЗИ


```text
Лабораторные работы:
1) привязка к характеристикам компьютера (лицензирование)
2) создание модели Энигмы
3) шифрование с открытым ключом
4) шифрование с симметричным ключом;
5) создание электронной подписи 
6) сжатие данных
```
	

```text
149-ФЗ: об информации, информационных технологиях и защите информации.
Информация - это сведения, сообщения, данные, независимо от формы их представления. Более философское определение - накопленный опыт человечества.
Жизненный цикл информации:
	создание,
	оценка (достоверность/бесполезность),
	подготовка к хранению,
	хранение,
	выборка,
	обработка,
	использование.
В результате использования появляются отчетные данные, которые поддаются оценке. Оцененные данные можно уничтожить. Обновленные данные также должны проходить оценку.

Документ - информация, зафиксированная на материальном носителе, с целью её дальнейшего изучения и передачи.
Электронный документ - документированная информация, представленная в электронной форме (воспринимается субъектом с использованием ЭВМ).
Защита информации - комплекс мер (правовых, организационных, технических), направленных на:
	* предотвращение неправомерных действий с информацией (доступ, модификация, копирование, уничтожение, блокировка, предоставление (конкретным субъектам) и распространение (неограниченному кругу);
	* соблюдение конфиденциальности информации ограниченного доступа;
	* реализацию права на доступ к информации.

СтандартТехническогоОбеспечения БанкаРоссии по ИнформационнойБезопасностиБанковскихСистем; 1.0-2014
Актив - всё, что имеет ценность для субъекта и находится в его распоряжении.
Информационная сфера:
	информация
	информационная инфраструктура
	субъекты, обрабатывающие информацию
	процедуры и правила, по которым информация обрабатывается
	система регулирования отношений (что, где, как)
Угроза - опасность, предполагающая возможность потери.
Безопасность - состояние защищенности в условии угроз.
Информационная безопасность - безопасность в условиях угроз в информационной сфере.

ИБ обеспечивает: доступность субъектам в том виде в каком была занесена в систему, целостность, конфиденциальность, "неотказуемость" (защита от отказа со стороны субъекта), подотчётность (обязательный контроль операций над информацией), аутентичность (подлинность) и достоверность.
Идентификация пользователя - присвоение уникального имени (логин).
Аутентификация - установление и подтверждение подлинности предъявленного идентификатора (пароль, материальный токен, биометрия)
Авторизация - определение и предоставление прав доступа субъекту к защищаемому ресурсу.

Ценность информации - мера ущерба, наносимого нарушением безопасности информации. Ключевой критерий при выборе средств защиты. Виды важности информации:
	* жизненно важная (функционирование системы невозможны)
	* важная (ущерб велик, но работоспособность сохраняется)
	* полезная (рабочая)
	* несущественная (вспомогательная)

Требования к системам защиты информации.
СЗИ должна удовлетворять критериям:
	простота
	полнота
	изоляция (от внешнего доступа)
	ответственность (см. неотказуемость)
	
Принципы защиты информации:
	* обоснованность доступа: пользователь должен иметь достаточный уровень доступа для выполнения своих обязанностей; но необходимы основания для этого доступа.
	* достаточная глубина контроля: система должна контролировать все действия на всех уровнях.
	* разграничение потоков информации: нельзя перемещать секретную информацию на общедоступный носитель, и наоборот.
	* чистота повторного использования: надежное уничтожение информации.
	* персональная ответственность.
	* целостность средств защиты: любая брешь в системе подвергает компрометации всю систему.

Персональные данные.
152-ФЗ о персональных данных: зафиксированы правила обработки ПД. ПД - любые данные, позволяющие идентифицировать конкретного человека.
Общедоступные источники персональных данных (имя-фамилия в резюме на сайте).
Специальные персональные данные - паспортные данные, СНИЛС и тд.
Биометрические персональные данные (отпечатки, медкарта, данные о здоровьи).
Трансграничная передача.

Цикл Деминга: планирование -> реализация -> проверка -> усовершенствование
                  ^______________________________________________/



16.09.15 -------------------------------------------------------------



Моделирование угроз нарушителя.
Важный этап при создании системы защиты информации. Цель моделирования - заставить разработчика конструктивно (на основе формальных требований) мыслить при проектировании систем с точки зрения информационной безопасности.

Моделирование угроз включает в себя шесть этапов:
1) определение активов (что)
	ресурсы (информация, пользователи её, инфраструктура)
	средства контроля безопасности
2) описание архитектуры
	границы системы
	функции и возможности
	технологии
3) декомпозиция системы
	области защиты: разное защищается по-разному
	политики безопасности
		проверка входных данных
		проверка подлинности
		авторизация
		управление конфигурацией
		выделение конфигурационных данных
		шифрование
		управление параметрами
		управление исключениями
		аудит
4) определение угроз
	источники
		природные
		техногенные
		антропогенные
			умышленные
			случайные
5) документирование
	цель
	риск
	методы борьбы
6) оценка серьёзности угроз
	потенциальный ущерб
	воспроизводность
	доступность атаки
	активы (субъекты + объекты)
	легкость обнаружения

Модель нарушителя.
	низкий уровень возможности - обычные пользователи системы, с крайне ограниченными возможностями
	средний уровень возможности - предусматривается создание и запуск новых средств с собственными функциями
	высокий - воздействие на функции системы
	абсолютный - имеют отношение к проектированию и реализации системы.

Хакеры:
	увлеченные (любопытство, развлечение, крутизна, получение денег)
	профессионалы (вербовка, изучение открытой информации, электронная почта, анализ "мусора" в виде распечаток и т.п., кража)


Классификация автоматизированных систем с точки зрения безопасности
группа 3: однопользовательские системы, пользователь имеет доступ ко всей информации (3A, 3B)
группа 2: многопользовательские системы, с одинаковым уровнем доступа (2A, 2B)
группа 1: многопользовательские системы с разным уровнем доступа (1A - 1D)


Модели доступа - устанавливают соответствие ресурсов к субъектам, к ним обращающимся.
Самая простая модель - матрица доступа (Харрисона-Ризо-Ульмана). Включает в себя перечень субъектов и объектов. В различных вариациях развития могут быть виды доступа, время доступа, различные условия. Отображается в виде простой таблицы, в которой перечисляются все субъекты и объекты. В ячейках указывается что субъект I имеет доступ к объекту J на чтение\запись\редактирование\удаление.



23.09.15 -------------------------------------------------------------

Мандатная модель (Белла-Лападулы). Уровень доступа субъекта должен быть не ниже чем уровень объекта. Аналогия с документами: совершенно секретные особой важности, совершенно секретные, секретные, для служебного пользования.
Ролевая модель. Развитие модели матрицы доступа. Дополняется ролями: объекты соответствуют ролям (одна матрица) и роли соответствуют субъектам (вторая матрица).

При создании систем необходимо журналирование. Оно может давать следующие профиты:
	выделение частых ошибок пользователей
	выделение нагруженности элементов в системе
	восстановление системы по журналам в случае сбоя



		Криптография
Шифрование информации.
Шифрование - преобразование открытого текста в зашифрованный, plaintext -> ciphertext, с целью сохранения конфиденциальности. Enciphering и deciphering.
Требования к алгоритмам шифрования:
1. сложность расшифровки и модификации
2. малое изменение исходного текста/ключа влечет значительные изменения шифра текста
3. область значений ключа должна исключать его перебор
4. стоимость дешифровки превышает стоимость данных
Требования были сформулированы голландцем Кергхофом. Правило Кергхофа: стойкость алгоритма определяется только секретностью ключа.
Рассеивание информации - влияние одного знака открытого текста на несколько знаков шифрованного текста.

Симметричные алгоритмы шифрования
Алгоритмы с единым секретным ключом шифрования и расшифровки. Включают в себя блочные и поточные алгоритмы.
	Блочные - используют для шифрования блоки. Алгоритмы подстановки, перестановки. Строка разбивается на блоки, которые преобразуются по отдельности. Результирующие блоки должны быть больше оригинальных.
Шифр Фейстеля - разбиение исходного сообщения на правую и левую части; левая складывается по модулю 2 с функцией ключа, и записывается в правую часть зашифрованного сообщения. Левая часть шифрованного - правая часть исходного.
Используются для небольших сообщений.
	Поточные - работают с непрерывным потоком данных. Передача начинается с синхропосылки. Дальше идёт первый блок данных, шифруется ключом (банально - XOR) с синхро. Зашифрованное выкладывается в канал, берётся второй блок данных, шифруется ключом с результатом первого блока, ...

Алгоритм "скитала".
Дощечка, намотана лента, на ленте буквы. Буквы, "находящиеся" на дощечке складываются в слово. Ключ - дощечка.

Перестановка по коду.
Правило: 3 1 2 4. Используется для перестановки элементов в тексте. "Текст" -> "кТет..."

PigPen.
A	B	C		J.	K.	L.
D	E	F	->	M.	N.	O.
G	H	I		P.	Q.	R.
	S				W.
T		U	->	X.		Y.
	V				Z.
Каждой букве ставится в соответствие символ в соответствие с таблицей, A: _|, J: _.|

Шифр Цезаря - сдвиг в алфавите.

Квадрат Полибия.
A B C D
v v v v
E F G H
.......

Великий шифр Людовика 14.
Пары символов меняются на кодовые значения. ое -> 123, ая -> 256. Вводится специальная комбинация, означающая удаление предыдущего слова.

Таблица омофонов.
Символу ставится в соответствие столько значений, сколь часто он встречается. A соответствует пять значений, Z одно. Размывает статистику, мешает частотному анализу.
Переходный вариант - вродебы подстановка на одном алфавите, но алфавит уже неоднозначный.

Одноалфавитные подстановки - для шифрования всех символов сообщения используется один алфавит.
Полиалфавитные - для шифрования каждого символа используются разные алфавиты.

Шифр Виженера.
ABCD ..K.. XYZ
BCDE ..L.. YZA
C .....M.... B
Все символы сдвигаются построчно. Ключом является какое-то слово. Над каждым символом сообщения записывается символ из ключа:
KEYKEYK
MESSAGE
Ищем в таблице замену в строке для буквы из ключа столбце буквы из сообщения. [K][M]=W.
Алгоритм Цезаря, повторённый 26 раз. В зависимости от ключа, заменяем по-разному.





30.09.15 -------------------------------------------------------------

Случайные числа
Используются например в артиллерии и методе монтекарло.

Реальные случайные числа:
	различные шумы
	время получения сетевых пакетов сетевой картой
	счетчик гейгера
	турбулентные потоки воздуха в вентиляторе
	действия пользователя: мышь, клавиши, движения перед камерой, микрофон

Квазислучайные числа - искусственно приведенные к равномерному распределению (монтекарло).

Псевдослучайные числа - числа, которые образуют последовательность, случайную с точки зрения статистических законов (друг от друга не зависят, а распределение как правило нормальное). Требования к алгоритму генерации:
	длина периода должна быть больше интервала использования
	независимость последовательных значений
	* равномерность распределения
	необратимость
Равномерность проверяют по двум критериям. Самый простой - возможность аппроксимации полиномом Н-ной степени. Вторая группа тестов оценивает равномерность по заданному количеству бит - отсекая какую-то часть (беря 5битные числа от 8битных), результат должен быть также распределен равномерно. Н-мерность - насколько глубоко можно отсекать так значения.

Использование в криптографии:
	целиком (одноразовый отрывной блокнот со случайными числами). Если кто-то крадёт блокнот, то последовательность скомпрометирована
	потоковое сложение с К, получаем новый ключ
	как инициализирующего значения для математической функции
	как порядковый номер в большом массиве
	как шаг в последовательности
	возведение бит

Алгоритмы генерации ПСЧ.
#1.
R = (msec * sec) mod N

#2. алгоритм фон неймана (метод серединных квадратов)
инициализирующее число: 1234
берем среднюю часть и возводим в квадрат: 23 -> 0529; 52 -> 1704; 70 -> 4900; 90 -> 8100; 10 -> 1000; 0 -> 0

#3. метод серединных произведений

#4. метод перемешивания
R_n1 = (R_n << 2) * (R_n >> 2)

#5. на числах Фиббоначи
Берется последняя цифра от числа: 0 1 1 2 3 5 8 3 1 ...

>№6. Простой Линейный Конгруэнтный Генератор.
Вычисляются члены рекуррентной последовательности по модулю натурального числа. R_n1 = (A * R_n + B) mod M. Качество очень сильно зависит от коэффициентов. Рекомендуемые значения:
A	B		M		Период
106	1283	6075	2^20
430	2531	11979	2^23
84589	45989	217728	2^35

#7. Вихрь Мерсенна
Состоит из двух частей: рекурсия аналогично предыдущим + закалка, убирающая зависимости. Используется матрица состояний 624стр*32стб.
На каждом шаге берется какое-то значение в матрице, XOR с первыми 32 битами, получается новая матрица состояний - из неё удалено слово А из начало, добавлено слово А(+)Б в конец (являющееся случайным словом).
Закалка - все зависимости бит из результата убираются.

Из равномерного распределения можно получить нормальное через Nr = M + \sigma*\Sum_k(Ravn_i(sqrt(3/k)))



07.10.15 -------------------------------------------------------------

Симметричное шифрование
Проблемы:
	ключом необходимо обмениваться
	ключ необходимо хранить
	ключ необходимо безопасно использовать - он не должен оставаться в памяти машины
	ключ необходимо безопасно уничтожать
ГОСТ 28/47 - используется ключ на 256 бит.
В большинстве алгоритмов используется шифр Фейстеля - подстановки и перестановки.

Data Encryption Standard (DES)
Длина ключа 56 бит; каждый восьмой бит контролирует четность предыдущих семи. Используются блоки по 64 бита.
Состоит из двух частей - преобразование ключа и собственно шифрование.
ПК: из 64бит исходного ключа необходимо получить 16 48битных раундовых ключей.
1. начальная перестановка в исходном ключе (остается 56 бит)
2. ключ делится на две половины C0, D0 по 28 бит
3. выполняется циклический сдвиг S1
Итерации 1,2,9,16 - сдвиг на 1 бит, остальные - на 2 бита
4. сдвинутые блоки объединяются и получается новый ключ 56
5. выполняется циклический сдвиг S2...

Ш:
0. входной блок М длины 64 бита
1. выполняется начальная перестановка P, каждому биту указывается место, куда его нужно переставить.
2. делится на две половины L0 R0 по 32 бита
3. R1 = L0 + фейстель(R0+k1), L1 = R1
Функция Фейстеля: R 32бита -расширяющая перестановка Е-> -XOR с ключом Ki 48бит-> разделяется на 8 блоков по 6 битов. 0,5 биты - номер строки, 1..4 - номер столбца
/*....................................*/
повторяется с 1 по 15 раунд. На 16м процедура меняется: L16 = L15 xor F(R15,K16); R16 = R15.
Полученные блоки объдиняются и выполняется конечная перестановка, обратная к перестановке Р

3-DES - тройное шифрование. C = E(K1, D(K2, E(K3, M))). M' = D(K3, E(K2, D(K1, C))). Размер ключа увеличивается до 192


Advanced Encryption Standard (AES)
Требования: блок 128бит, ключи 128, 192 и 256. Алгоритм должен быть криптостойким по отношению к атакам, известным на момент создания. Ясная и обоснованная структура самого алгоритма. Отсутствие слабых и эквивалентных ключей (Е(к1) == Е(к2)). Скорость. Минимальная память. Возможность распараллеливать вычисления при зашифровке. Использование как для блочного шифрования так и для других видов.
Алгоритм Rijndael.



14.10.15 -------------------------------------------------------------

DES:
1.преобразование ключа (56бит -> 16х56бит)
2. Шифрование (перестановки, подстановки)

Алгоритм AES
*фото1, фото2*
Data: 128бит (4 слова по 32бит)
K_i: 128бит, 192бит, 256бит

В 128битном ключе: ~10^36 вариантов, 
Составление раундовых ключей:
	W[0] копируется из ключа K
	W[i] = (SubByte(ShiftByte(W[i-1])) xor RCon[i]) xor W[i-Nk] для элементов, i mod Nk == 0 (кратных длине ключа)
	Для остальных W[i] = W[i-1] xor (W[i - Nk])

Шифрование: 4 операции
1. сложение с ключом, AddRoundKey
2. сдвиг строчек, ShiftRows
3. смешивание столбцов, MixColumns
4. подстановка SubBytes
Суть АЕС - последовательное применение этих операций. На последнем раунде не используется перемешивание колонок.



28.10.15 -------------------------------------------------------------

Хеш-функция - преобразование, используемое для аутентификации сообщений, определяемое следующими свойствами:
	применима к блоку данных любой длины
	создание выхода фиксированной длины
	необратимость
	легкость вычисления
	(a != b) => (H(a) != H(b))
Применение:
	аутентификация (прислался тот же файл что и отправлялся)
	защита данных (хранить в базе не сам пароль, а его хеш)

Примеры функций:
MessageDigest
	MD5, 1991. Входные данные - 128бит, выход - 128бит. Основная уязвимость - "тесты на дни рождения"
Secure Hash Algorithm
	SHA-0, 1993. 512бит => 160бит. Прожил всего полгода.
	SHA-1. 512 => 160, устранены все недостатки ша0. На долгое время стал стандартом.
	SHA-2. Собирательное обозначение для целого семейства алгоритмов: ша224, ша256, 384, 512; различный размер выходных даннов. Вход 512/1024бит.
Чем больше захватывается блок в алгоритме - тем больше используется информации для создания хэша, чем меньше на выходе - тем выше вероятность нахождения двух разных блоков, дающих одинаковый выход

Смысл алгоритмов хеш-функций - входной блок делится на части, над которыми выполняются XOR, SHIFT(R,L), AND, OR, etc. Получаем перемешивание данных внутри каждого блока. Для каждого блока заводятся "константы", которые складываются\умножаются с блоками данных. Каждый блок перемешивается N раундов; "константы" заменяются на биты преобразованного предыдущего блока.





02.12.15 -------------------------------------------------------------

Квантовая криптография

Метод передачи информации, основанный на принципах квантовой физики. "Обычная" передача - электроны (частицы) и разность потенциалов (поток). Квантовая передача - использование единичных квантовых частиц.
Принцип неопределенности Гейзенберга - импульс и координаты - сопряженные величины (также напряженность эл. и маг. полей; ток и напряжение). Произведение среднеквадратичных отклонений измерений каждой из величин не может превышать константу. Чем точнее измеряется одно, тем меньше точность измерения другого.

Можно построить криптографическую систему: информация не прячется\преобразовывается, но можно увидеть, что получен несанкционированный доступ. Перехваченный сигнал будет передан дальше в искаженном виде.

Алгоритм BB84
Отправитель Алиса, получатель Боб - "легальные" пользователи; Ева - криптоаналитик. Для кодирования информации используются фотоны - могут быть поляризованы ортогонально либо диагонально. Из ортогонального (+) - поляризация 0/90 градусов (0 и 1), из диагонального (х) - 45/135 градусов (тоже 0 и 1).
На передаваемый сигнал требуется накладывать правильный базис, иначе могут появляться ошибки.
I первичный этап
	1. выбор поляризаторов:
	А	1	0	1	1	0
		+	х	х	+	+
		->	/>	\>	->	|^
	2. направляется в квантовый канал
	3. прием фотонов
	Б	->	/>	->	->	|^
		x	+	x	+	x
		?	?	\>	->	?
		?	?	1	1	?
	4. по открытому каналу Б сообщает А, какие поляризаторы он выбрал
		-''- А сообщает Б угаданные поляризаторы
	5. выбирают угаданные биты
II сверка данных
	6. сверка контрольной суммы (передается также по открытому каналу)
+ исключается прослушивание (чуть что - меняем конфигурацию и начинаем заново)
- информация передается не целиком
- защищается канал а не информация
=> используется в алгоритмах квантового распределения ключей

Главная проблема - для передачи каждого бита информации требуется ~1 фотон. Проблемы с передачей информации.
Увеличиваем число фотонов на один бит - получаем выше надежность доставки, но снижаем безопасность.
Атом излучает фотоны с противоположной (горизонтальная\вертикальная) поляризацией в обе сторону. В одну сторону ведётся передача, в другое запоминание.

Используются высокочувствительные фотодиоды, ловящие фотоны. Физический недостаток - если их "засветить", то управляя интенсивностью сигнала можно управлять считываемой информацией.



09.12.15 -------------------------------------------------------------

Сжатие данных
Процесс сокращения числа бит, необходимых для хранения одного и того же числа информации. Сокращение избыточности. Выделяют три метода оного сокращения:
1. устранение повторений
2. изменение модели хранения данных (короткие последовательности для часто встречающихся элементов, длинные для редких)
3. сжатие с потерями
ДОС6.22, алгоритм DriveSpace сжатия на лету.
Самый простой алгоритм сжатия: добавляем бит к повторяющейся последовательности, 0 - данные, 1 - число повторов.

Алгоритм Шеннона-Фано, 1948
1. Строится таблица частот встречающихся символов.
2. Выбираются два подмножества символов, в которых сумма частот оных примерно равна (например: 10,9,5,1 частоты -> 10+1, 9+5), строится дерево. 0 - налево по дереву, 1 - направо. Буквы можно кодировать, например:
ABCD
	0 BC
		0 B
		1 C
	1 AD
		0 A
		1 D
Таким образом, A=10
Подмножества выделяются до тех пор, пока множество не будет содержать один символ.
Недостаток - нет четкой формализации, как будет выглядеть модель сжатия (сжимать можно разными методами). Четкого соответствия нет - множества выбираются по каким-то внутренним принципам, которые могут расходиться в разных случаях.

Алгоритм Хаффмана
Основное отличие - построение дерева начинается с листьев в корень.
1. Таблица частот (сортировка)
2. Строится дерево: два символа с наименьшим весом (встречаемостью) (C,D). Они образуют узел с весом их суммарной встречаемости. Суммарный вес (6) заменяет их в таблице частот. Дальше берем 6 и B, образуют узел 15. Дальше берем 15 и A, образуем узел 25.
3. Аналогично Ш-Ф, помечаются дуги дерева как 0 налево и 1 направо.
4. Бит 1 в файле всегда обозначает лист, а количество нулей перед ним - какой именно из листов.
Вместе с файлом необходимо хранить и исходную таблицу частот (либо само дерево).
Необходимо также учитывать остающиеся в хвосте пустые биты - они могут раскодироваться в совершенно лишнюю информацию.

Адаптивный алгоритм Хаффмана
Позволяет избавиться от необходимости хранить дерево. При считывании очередного символа - перестраивается модель данных. Считали второй символ - получили два символа с равной частотй, четвертый, пятый; каждый раз перекодируется дерево. Алгоритм будет катастрофически медленным. Узел должен встраиваться в дерево сразу же на правильную позицию.

Алгоритм LZW (Лемпэл Зив 1978; Уэлч 1984)
[Going, going, gone!]
Строится таблица: код символа | префикс | суффикс. Заполняется символами из АСКИ-таблицы с -1 во 2-м и темже символом в 3-м столбце.
Считывается первый символ из файла (G=71) и второй (o=111):
256	71	111
Третий (i=105):
257	111	105
Далее:
258	105	110
259	110	103
260	103	44
...
264	111	105	//соответствует oi во втором гоинге.
Это позволяет нам заменить комбинацию 111 105 на 257 110

Закодированным файлом будет последовательность префиксов начиная с 256 строки. Когда считываются элементы, если символ выходит за пределы 256 - он уже где-то есть в таблице выше.

Алгоритм арифметического кодирования
Опять таблица частот. BILL GATES ->
символ	вероятность	интервал
_	0.1	0-.1
a	.1	.1-.2
b	.1	.2-.3
e	.1
g	.1
i	.1	
l	.2	.6-.8
s	.1
t	.1	.9-1
Кодируется дробным числом. Интервал 0..1 разбивается на вероятности, получаем дерево интервалов. По нему можно построить другую таблицу:
символ	низ	верх	интервал
B	.2	.3	.1
I	.25	.26	.01
L	.256	.258	.002
В конечном итоге, строка будет закодирована дробью: 0.257167752
```